From 84172954633d95a0fd90193a4eaf71ef5342165c Mon Sep 17 00:00:00 2001
From: Mika Laitio <lamikr@pilppa.org>
Date: Wed, 11 May 2011 18:55:21 +0300
Subject: [PATCH 3/4] pwr-btn fix for display blank/unblank

Enables the display blanking and unblanking by using the power
button or lock screen button. When display is blanked, it's always
also locked.

In unblank case there is a difference between lock key and pwr button
key. Power button press only unblanks the screen but leaves the lock ui
still in place. Lock key will also hide the lock ui.

In the case of power button, the lockkey event is generated only when
the power button is released. This allow user to see the shutdown button
if the device is turned off by keeping the power button down for a long
time.

Signed-off-by: Mika Laitio <ext-mika.1.laitio@nokia.com>
---
 event-input.c |   65 +++++++++++++++++++++++++++++++++++++++++++--------------
 tklock.c      |   19 ++++------------
 tklock.h      |   16 ++++++++++++++
 3 files changed, 70 insertions(+), 30 deletions(-)

diff --git a/event-input.c b/event-input.c
index c5ea85e..2d56789 100644
--- a/event-input.c
+++ b/event-input.c
@@ -78,6 +78,7 @@
 					 * mce_conf_get_string()
 					 */
 #include "datapipe.h"			/* execute_datapipe() */
+#include "tklock.h"
 
 /** ID for touchscreen I/O monitor timeout source */
 static guint touchscreen_io_monitor_timeout_cb_id = 0;
@@ -357,6 +358,7 @@ static void setup_keypress_repeat_timeout(void)
  */
 static void keypress_cb(gpointer data, gsize bytes_read)
 {
+    int tklock_ui_state;
 	submode_t submode = mce_get_submode_int32();
 	struct input_event *ev;
 
@@ -379,22 +381,53 @@ static void keypress_cb(gpointer data, gsize bytes_read)
 					       USE_INDATA, CACHE_INDATA);
 		}
 
-		/* For now there's no reason to cache the keypress
-		 *
-		 * If the event eater is active, and this is the press,
-		 * don't send anything; never eat releases, otherwise
-		 * the release event for a [power] press might get lost
-		 * and the device shut down...  Not good(tm)
-		 *
-		 * Also, don't send repeat events, and don't send
-		 * keypress events for the focus and screenlock keys
-		 */
-		if ((ev->code != KEY_CAMERA_FOCUS) &&
-	            (ev->code != KEY_SCREENLOCK) &&
-	            ((((submode & MCE_EVEATER_SUBMODE) == 0) &&
-		       (ev->value == 1)) || (ev->value == 0))) {
-			(void)execute_datapipe(&keypress_pipe, &ev,
-					       USE_INDATA, DONT_CACHE_INDATA);
+		if (ev->code == KEY_POWER) {
+			if (ev->value == 0) { // = power button release event
+				display_state_t display_state = datapipe_get_gint(display_state_pipe);
+				if (display_state == MCE_DISPLAY_OFF) {
+					// open display but leave the lock ui
+					(void)execute_datapipe(&display_state_pipe,
+								       GINT_TO_POINTER(MCE_DISPLAY_ON),
+								       USE_INDATA, CACHE_INDATA);
+				}
+				else {
+                    // display on, check whether we have screen lock ui active
+					tklock_ui_state = get_tklock_ui_state();
+					if ((tklock_ui_state == MCE_TKLOCK_UI_UNSET) || // = UNSET
+						(tklock_ui_state == MCE_TKLOCK_UI_NONE)) {  // MCE_TKLOCK_UI_NONE
+                        // no lock ui visible, request to blank and activate lock ui
+						(void)execute_datapipe(&lockkey_pipe,
+											GINT_TO_POINTER(1),
+											USE_INDATA, CACHE_INDATA);
+					}
+					else {
+						// screen lock UI already active --> request just to blank the screen.
+                        // we can not call lockkey-pipe here, because it would cause the
+                        // lock ui unlock and keep display on
+						(void)execute_datapipe(&display_state_pipe,
+											GINT_TO_POINTER(MCE_DISPLAY_OFF),
+											USE_INDATA, CACHE_INDATA);
+					}				}
+			}
+		}
+		else {
+			/* For now there's no reason to cache the keypress
+			 *
+			 * If the event eater is active, and this is the press,
+			 * don't send anything; never eat releases, otherwise
+			 * the release event for a [power] press might get lost
+			 * and the device shut down...  Not good(tm)
+			 *
+			 * Also, don't send repeat events, and don't send
+			 * keypress events for the focus and screenlock keys
+			 */
+			if ((ev->code != KEY_CAMERA_FOCUS) &&
+					(ev->code != KEY_SCREENLOCK) &&
+					((((submode & MCE_EVEATER_SUBMODE) == 0) &&
+				   (ev->value == 1)) || (ev->value == 0))) {
+				(void)execute_datapipe(&keypress_pipe, &ev,
+							   USE_INDATA, DONT_CACHE_INDATA);
+			}
 		}
 	}
 
diff --git a/tklock.c b/tklock.c
index cf9565a..1e8d038 100644
--- a/tklock.c
+++ b/tklock.c
@@ -143,20 +143,6 @@ static const gchar *mce_keypad_sysfs_disable_path = NULL;
 /** Submode at the beginning of a call */
 static submode_t saved_submode = MCE_INVALID_SUBMODE;
 
-/** TKLock UI state type */
-typedef enum {
-	/** TKLock UI state unknown */
-	MCE_TKLOCK_UI_UNSET = -1,
-	/** No TKLock UI active */
-	MCE_TKLOCK_UI_NONE = 0,
-	/** Normal TKLock UI active */
-	MCE_TKLOCK_UI_NORMAL = 1,
-	/** Event eater UI active */
-	MCE_TKLOCK_UI_EVENT_EATER = 2,
-	/** Slider UI active */
-	MCE_TKLOCK_UI_SLIDER = 3
-} tklock_ui_state_t;
-
 /** TKLock UI state */
 static tklock_ui_state_t tklock_ui_state = MCE_TKLOCK_UI_UNSET;
 
@@ -2508,6 +2494,10 @@ EXIT:
 	return;
 }
 
+int get_tklock_ui_state(void) {
+	return (int)tklock_ui_state;
+}
+
 /**
  * Init function for the touchscreen/keypad lock component
  *
@@ -2741,3 +2731,4 @@ void mce_tklock_exit(void)
 
 	return;
 }
+
diff --git a/tklock.h b/tklock.h
index a963229..3a48c4c 100644
--- a/tklock.h
+++ b/tklock.h
@@ -138,4 +138,20 @@
 gboolean mce_tklock_init(void);
 void mce_tklock_exit(void);
 
+/** TKLock UI state type */
+typedef enum {
+	/** TKLock UI state unknown */
+	MCE_TKLOCK_UI_UNSET = -1,
+	/** No TKLock UI active */
+	MCE_TKLOCK_UI_NONE = 0,
+	/** Normal TKLock UI active */
+	MCE_TKLOCK_UI_NORMAL = 1,
+	/** Event eater UI active */
+	MCE_TKLOCK_UI_EVENT_EATER = 2,
+	/** Slider UI active */
+	MCE_TKLOCK_UI_SLIDER = 3
+} tklock_ui_state_t;
+
+int get_tklock_ui_state(void);
+
 #endif /* _TKLOCK_H_ */
-- 
1.7.1

